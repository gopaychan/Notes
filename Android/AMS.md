##### 1. Activity 的启动流程
1. ActivityStarter.startActivityLock 验证intent、Class、Permission等，保存将要启动的Activity的Record。
2. ActivityStarter.startActivityUnChecked 检查将要启动的Activity的launchMode和启动Flag，根据launchMode和Flag配置Task。
3. ActivityStack.startActivityLocked 任务栈历史栈配置
4. ActivityStack.resumeTopActivityInnerLocked 查找要进入暂停的Activity
5. ActivityStack.startPausingLocked 通过ipc告诉要暂停的Activity进入暂停
6. ActivityThread.handlePauseActivity
    1. 正式让之前的Activity暂停
    2. 告诉AMS已经暂停完成
7. ActivityManagerService.activityPaused
8. ActivityStack.activityPauseLocked
9. ActivityStackSupervisor.resumeTopAcitivitiesLocked
10. ActivityStack.resumeTopActivityLock 验证是否该启动的Activtiy所在的进程和app是否存在，若存在，直接启动（realStartActivityLocked），否则，准备创建该线程
11. ActivityStackSupervisor.startSpecificActivityLocked 该进程不存在，创建进程
12. ActivityManagerService.startProcessLocked 通过Process.start("android.app.ActivityThread")启动进程
13. ActivityThread.main
14. ActivityThread.attach 
15. IActivityManager.attachApplication
16. ActivityStackSupervisor.attachApplicationLocked 准备启动应用，先查找MainActivity
17. ActivityStackSupervisor.realStartActivityLocked IPC通知ActivityThread
18. ActivityThread.scheduleLaunchAcitivy
19. Instrumentation.newActivity
20. activity.attach
21. Instrumentation.callActivityOnCreate

##### 2. Activity State 切换控制（以launch为例子）
1. ActivityStackSupervisor.realStartActivityLocked里面会新建ClientTransaction对象clientTransaction并传入app.thread（ActivityThread.ApplicationThread），r.appToken（ActivityRecord.Token，ActivityRecord构造方法里面新建的）。
2. 调用clientTransaction的addCallback方法新建LaunchActivityItem对象传入各个参数。
3. 调用clientTransaction的setLifecycleStateRequest方法传入希望结束的状态，ResumeActivityItem或者PauseActivityItem。
4. 调用``` mService.getLifecycleManager().scheduleTransaction(clientTransaction)```开始切换Activity状态，mService为ActivityManagerService，getLifecycleManager()获得的是AMS里面的一个ClientLifecycleManager对象。
5. 调用ClientLifecycleManager的scheduleTransaction方法实际上是调用了clientTransaction的schedule方法。最终调用的是ApplicationThread的scheduleTransaction方法，传入clientTransaction。（这一步实现了IPC）
6. ActivityThread里面会调用TransactionExecutor的execute方法传入transaction对象。
7. TransactionExecutor里面先会调用callbacks里面的item的execute方法，最后才调用lifecycleState的execute，即会先调用LaunchActivityItem的execute方法，调用的时候会把token传进去。
8. LaunchActivityItem的execute方法会新建ActivityClientRecord对象保存传进来的token，调用ActivityThread的handleLaunchActivity方法。
9. 其他还有preExecute，postExecute方法，在execute前后做一些处理（比如pause最后会在PostExecute里面调用AMS的activityPaused方法通知Activity已经paused）。

##### 3. 其他
1. ActivityRecord.Token
    1. ActivityRecord的构造方法里面会新建ActivityRecord.Token并把this保存在里面。token会传递到client端并保存在ActivityClientRecord里面，token主要是来标注client端的ActivityClientRecord和server端的ActivityRecord，像调用activityPaused方法的时候就需要传入token，这样在server端就可以找到对应的ActivityRecord。
    2. ActivityStack的startActivityLocked方法里面会调用ActivityRecord的createWindowContainer方法，这个方法会new一个AppWindowContainerController对象mWindowContainerController，AppWindowContainerController的构造方法会调用createAppWindow方法新建一个AppWindowToken对象，其父类的构造方法最终会调用到DisplayContent（每个DisplayId都会有一个对应的DisplayContent保存在RootWindowContainer里面，RootWindowContainer是WindowManagerService的一个对象mRoot，在其构造方法里初始化）的addWindowToken方法保存token（ActivityRecord.Token）和对应的AppWindowToken对象。
    3. ActivityThread的performLaunchActivity方法里面调用Activity的Attach方法的时候会把ActivityClientRecord的token传进去保存在Activity的mToken里面。
        1. attach里面新建window（PhoneWindow）之后会调用其setWindowManager方法传入mToken保存在Window的mAppToken里面，并调用WindowManagerImpl的createLocalWindowManager方法传入this，新建WindowManagerImpl对象mWindowManager。
        2. 在ActivityThread的handleResumeActivity里面调用addView的时候，WindowMnangerGlobal的addView方法会调用adjustLayoutParamsForSubWindow为window的Attributes的token赋值，因为是Activity的window（```mContainer==null```）所以token赋值为mParentWindow（即当前window，WindowManagerImpl的构造方法里传进来的window付给mParentWindow）的mAppToken。
    4. WindowManagerService新建WindowState前会从DisplayContent获取对应ActivityRecord.Token（WindowManager.LayoutParams的token）的AppWindowToken，并传入。
2. FLAG_ACTIVITY_NEW_TASK：用该标志启动的Activity 如果该Activity已经在某个Task里面了，则把她显示到前台不重新新建Task，除非加 FLAG_ACTIVITY_MULTIPLE_TASK 这个flag。
3. android:taskAffinity：当开始一个没有Intent.FLAG_ACTIVITY_NEW_TASK标志的Activity时，任务共用性affinities不会影响将会运行该新活动的Task:它总是运行在启动它的Task里。但是，如果使用了NEW_TASK标志，那么共用性（affinity）将被用来判断是否已经存在一个有相同共用性（affinity）的Task。如果是这样，这项Task将被切换到前面而新的Activity会启动于这个Task的顶层。